# 1.统一化处理异常

## 代码

```java
package com.zzt.blog.exception;

import lombok.Data;
import lombok.EqualsAndHashCode;


/**
 * 业务异常
 * @author 227
 */
@EqualsAndHashCode(callSuper = true)
@Data
public class BusinessException extends RuntimeException {
    
    private Integer code;
    
    /**
     * 构造函数
     * @param message 错误消息
     */
    public BusinessException(String message) {
        super(message);
        this.code = 500;
    }

    /**
     * 构造函数
     * @param code 错误码
     * @param message 错误消息
     */
    public BusinessException(Integer code, String message) {
        super(message);
        this.code = code;
    }
    /**
     * 构造函数
     * @param errorCodecode 错误码枚举
     */
    public BusinessException(ErrorCode errorCodecode) {
        
        super(errorCodecode.getMessage());
        this.code = errorCodecode.getCode();
    }
    /**
     * 构造函数
     * @param message 错误消息
     * @param cause 原始异常
     */
    public BusinessException(String message, Throwable cause) {
        super(message, cause);
        this.code = 500;
    }
    
    /**
     * 构造函数
     * @param code 错误码
     * @param message 错误消息
     * @param cause 原始异常
     */
    public BusinessException(Integer code, String message, Throwable cause) {
        super(message, cause);
        this.code = code;
    }
}
```

```java
package com.zzt.blog.exception;

import lombok.Getter;

/**
 * 错误码枚举
 * @author 227
 */
@Getter
public enum ErrorCode {
    
    // 通用错误码
    SUCCESS(200, "操作成功"),
    SYSTEM_ERROR(500, "系统错误"),
    PARAM_ERROR(400, "参数错误"),
    UNAUTHORIZED(401, "未授权"),
    FORBIDDEN(403, "禁止访问"),
    NOT_FOUND(404, "资源不存在"),
    
    // 业务错误码 (1000-1999)
    USER_NOT_FOUND(1001, "用户不存在"),
    USERNAME_ALREADY_EXISTS(1002, "用户名已存在"),
    PASSWORD_ERROR(1003, "密码错误"),
    USER_DISABLED(1004, "用户被禁用"),
    EMAIL_ALREADY_EXISTS(1005, "邮箱已经注册，请登录"),
    // 文章相关错误码 (2000-2999)
    ARTICLE_NOT_FOUND(2001, "文章不存在"),
    CATEGORY_NOT_FOUND(2002, "分类不存在"),
    
    // 评论相关错误码 (3000-3999)
    COMMENT_NOT_FOUND(3001, "评论不存在");
    
    private final Integer code;
    private final String message;
    
    ErrorCode(Integer code, String message) {
        this.code = code;
        this.message = message;
    }
}
```

```java
package com.zzt.blog.exception;
/**
 * 全局异常处理器
 * @author 227
 */
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    /**
     * 处理业务异常
     */
    @ExceptionHandler(BusinessException.class)
    public Result<Void> handleBusinessException(BusinessException e) {
        log.error("业务异常: {}", e.getMessage(), e);
        return Result.error(e.getCode(), e.getMessage());
    }

    /**
     * 处理参数校验异常
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public Result<Void> handleMethodArgumentNotValidException(MethodArgumentNotValidException e) {
        BindingResult bindingResult = e.getBindingResult();
        StringBuilder sb = new StringBuilder("参数校验失败:");
        for (FieldError fieldError : bindingResult.getFieldErrors()) {
            sb.append(" [").append(fieldError.getField()).append("]").append(fieldError.getDefaultMessage()).append(";");
        }
        String msg = sb.toString();
        log.error("参数校验异常: {}", msg);
        return Result.error(ErrorCode.PARAM_ERROR.getCode(), msg);
    }

    /**
     * 处理绑定异常
     */
    @ExceptionHandler(BindException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public Result<Void> handleBindException(BindException e) {
        List<FieldError> fieldErrors = e.getBindingResult().getFieldErrors();
        StringBuilder sb = new StringBuilder("参数绑定失败:");
        for (FieldError fieldError : fieldErrors) {
            sb.append(" [").append(fieldError.getField()).append("]").append(fieldError.getDefaultMessage()).append(";");
        }
        String msg = sb.toString();
        log.error("参数绑定异常: {}", msg);
        return Result.error(ErrorCode.PARAM_ERROR.getCode(), msg);
    }

    /**
     * 处理所有其他异常
     */
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public Result<Void> handleException(Exception e) {
        log.error("系统异常: {}", e.getMessage(), e);
        return Result.error(ErrorCode.SYSTEM_ERROR.getCode(), "系统异常，请联系管理员");
    }
}
```

### 类结构说明
1. **类注解**:
   - `@Slf4j`: 使用 Lombok 提供的日志注解，自动生成 [log](file://com\baomidou\mybatisplus\extension\service\impl\ServiceImpl.java#L18-L18) 对象用于日志记录。
   - `@RestControllerAdvice`: Spring 提供的注解，结合了 `@ControllerAdvice` 和 `@ResponseBody`，用于定义全局异常处理器并直接返回 JSON 响应。

2. **异常处理方法**:
   - 每个方法使用 `@ExceptionHandler` 指定要处理的异常类型。
   - 部分方法使用 `@ResponseStatus` 自定义 HTTP 状态码。

---

### 方法功能解析

1. **处理业务异常 [handleBusinessException](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\exception\GlobalExceptionHandler.java#L26-L30)**
   - 处理自定义的 [BusinessException](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\exception\BusinessException.java#L10-L63) 异常。
   - 日志记录异常信息。
   - 返回统一的错误响应格式 [Result](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\util\Result.java#L14-L107)，包含异常的错误码和消息。

2. **处理参数校验异常 [handleMethodArgumentNotValidException](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\exception\GlobalExceptionHandler.java#L35-L46)**
   - 处理 Spring MVC 参数校验失败抛出的 `MethodArgumentNotValidException`。
   - 从异常中提取校验失败的字段信息 (`FieldError`)，拼接成易读的错误消息。
   - 返回 HTTP 400 状态码和校验失败的详细信息。

3. **处理绑定异常 [handleBindException](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\exception\GlobalExceptionHandler.java#L51-L62)**
   - 处理数据绑定失败抛出的 `BindException` (比如表单提交时的类型转换错误)。
   - 逻辑与参数校验异常处理类似，提取字段错误信息并格式化。
   - 同样返回 HTTP 400 状态码。

4. **处理其他异常 [handleException](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\exception\GlobalExceptionHandler.java#L67-L72)**
   - 兜底处理所有未明确捕获的异常 (`Exception`)。
   - 返回 HTTP 500 状态码和通用错误提示，避免敏感信息泄露。

---

### 关键设计点
- **统一响应格式**: 所有异常均返回 `Result<Void>` 对象，保持前后端交互一致性。
- **日志记录**: 每个异常都记录详细日志，便于排查问题。
- **用户友好**: 参数校验/绑定异常会拼接具体字段的错误信息，帮助快速定位问题。



# 2.JWT鉴权

用户只有登录获取到token，才能访问后续的其他接口

## 依赖

```java
<!-- JWT依赖 -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.11.5</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
```

## 代码

### JwtAuthenticationFilter

```java
package com.zzt.blog.config;

/**
 * @author 227
 */
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtUtils jwtUtils;

    public JwtAuthenticationFilter(JwtUtils jwtUtils) {
        this.jwtUtils = jwtUtils;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {

        final String authorizationHeader = request.getHeader("Authorization");

        String username = null;
        String jwt = null;

        // 检查Authorization头是否存在且以Bearer开头
        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            jwt = authorizationHeader.substring(7);
            try {
                username = jwtUtils.getUsernameFromToken(jwt);
            } catch (Exception e) {
                logger.error("JWT令牌验证失败", e);
            }
        }

        // 如果成功提取用户名且当前SecurityContext中没有认证信息，则进行认证
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            // 创建认证令牌
            UsernamePasswordAuthenticationToken authenticationToken =
                    new UsernamePasswordAuthenticationToken(username, null, new ArrayList<>());
            
            authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            
            // 将认证信息设置到SecurityContext中
            SecurityContextHolder.getContext().setAuthentication(authenticationToken);
        }
        
        filterChain.doFilter(request, response);
    }
}
```

这是一个基于 JWT (JSON Web Token) 的身份验证过滤器 [JwtAuthenticationFilter](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\config\JwtAuthenticationFilter.java#L20-L61)，继承自 Spring Security 的 [OncePerRequestFilter](file://org/springframework/web/filter/OncePerRequestFilter.java)，用于在每个请求中验证 JWT 令牌并设置用户认证信息。以下是详细解析：

---

#### **核心组件**
1. **依赖注入**  
   - 通过构造函数注入 [JwtUtils](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\util\JwtUtils.java) 工具类，用于解析和验证 JWT 令牌。

2. **继承关系**  
   - 继承 `OncePerRequestFilter` 确保每个请求只过滤一次，避免重复处理。

---

#### **方法逻辑解析**  
#### [doFilterInternal](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\config\JwtAuthenticationFilter.java#L30-L62) 方法流程  
1. **提取 JWT 令牌**  
   ```java
   final String authorizationHeader = request.getHeader("Authorization");
   if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
       jwt = authorizationHeader.substring(7); // 去掉 "Bearer " 前缀
       username = jwtUtils.getUsernameFromToken(jwt); // 从令牌中提取用户名
   }
   ```

   - 检查请求头 `Authorization` 是否以 `Bearer ` 开头。
   - 提取令牌并调用 [JwtUtils](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\util\JwtUtils.java#L18-L81) 解析用户名。

2. **异常处理**  
   ```java
   catch (Exception e) {
       logger.error("JWT令牌验证失败", e); // 记录验证失败日志
   }
   ```

   - 令牌解析失败时记录日志，但**不中断请求**（继续执行过滤器链）。

3. **设置认证上下文**  
   ```java
   if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
       UsernamePasswordAuthenticationToken authenticationToken = 
           new UsernamePasswordAuthenticationToken(username, null, new ArrayList<>());
       authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
       SecurityContextHolder.getContext().setAuthentication(authenticationToken);
   }
   ```

   - **条件**：成功提取用户名 + 当前无认证信息。
   - **操作**：
     - 创建无密码的认证对象 `UsernamePasswordAuthenticationToken`（密码已通过 JWT 验证）。
     - 附加请求详情（如 IP、SessionID）。
     - 将认证信息存入 `SecurityContextHolder`，供后续过滤器或控制器使用。

4. **继续过滤器链**  
   ```java
   filterChain.doFilter(request, response);
   ```

   - 无论是否认证成功，最终都会放行请求。

---

#### **关键设计点**
1. **无状态认证**  
   - 完全依赖 JWT 令牌，无需 Session 或数据库查询。

2. **安全上下文隔离**  
   - 通过 `SecurityContextHolder` 确保每个请求的认证信息独立。

3. **轻量级验证**  
   - 仅验证令牌有效性，不涉及权限角色（权限检查可结合 `@PreAuthorize` 注解）。

4. **与全局异常处理器协作**  
   - 若 [JwtUtils](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\util\JwtUtils.java#L18-L81) 抛出异常（如令牌过期），会被 [GlobalExceptionHandler](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\exception\GlobalExceptionHandler.java#L67-L72) 捕获并返回标准化错误响应。

---

#### **典型流程示例**
1. **请求携带有效令牌**  
   
   ```http
   GET /api/user/profile
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
   ```
```
   
   - 过滤器提取用户名 `Alice` 并设置认证上下文。
- 后续控制器可通过 `@AuthenticationPrincipal` 获取用户信息。
   
2. **请求携带无效令牌**  
   
- 记录错误日志，但返回 200 状态码（实际业务可能返回 401，需额外配置）。
   
3. **无令牌请求**  
   
   - 直接放行，由其他安全机制（如 `antMatchers().permitAll()`）决定是否允许访问。

### JwtUtils

​```java
package com.zzt.blog.util;


/**
 * @author 227
 */
@Component
public class JwtUtils {

    // 令牌密钥
    private static final Key key = Keys.secretKeyFor(SignatureAlgorithm.HS256);
    
    // 令牌过期时间（毫秒）
    private static final long JWT_TOKEN_VALIDITY = 24 * 60 * 60 * 1000;

    // 从令牌中获取用户名
    public String getUsernameFromToken(String token) {
        return getClaimFromToken(token, Claims::getSubject);
    }

    // 从令牌中获取过期日期
    public Date getExpirationDateFromToken(String token) {
        return getClaimFromToken(token, Claims::getExpiration);
    }

    // 从令牌中获取指定声明
    public <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = getAllClaimsFromToken(token);
        return claimsResolver.apply(claims);
    }

    // 从令牌中获取所有声明
    private Claims getAllClaimsFromToken(String token) {
        return Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token).getBody();
    }

    // 检查令牌是否已过期
    private Boolean isTokenExpired(String token) {
        final Date expiration = getExpirationDateFromToken(token);
        return expiration.before(new Date());
    }

    // 从令牌中获取用户ID
    public Long getUserIdFromToken(String token) {
        final Claims claims = getAllClaimsFromToken(token);
        return claims.get("userId", Long.class);
    }

    // 生成令牌的核心方法
    private String doGenerateToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(subject)
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + JWT_TOKEN_VALIDITY))
                .signWith(key)
                .compact();
    }

    // 验证令牌
    public Boolean validateToken(String token, String username) {
        final String tokenUsername = getUsernameFromToken(token);
        return (tokenUsername.equals(username) && !isTokenExpired(token));
    }
    public String generateToken(String username, Long userId) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId);
        return doGenerateToken(claims, username);
    }
}
```

### UserController

```java
package com.zzt.blog.controller;
/**
 * @author 227
 */ // 用户控制器
@RestController
@RequestMapping("/users")
@Tag(name = "用户管理")
public class UserController {
    @Autowired
    private UserService userService;
    
    @Autowired
    private JwtUtils jwtUtils;
    @PostMapping("/login")
    @Operation(summary = "登录用户")
    public Result<Map<String, Object>> loginUser(@RequestBody LoginDTO loginDTO) {
        if(loginDTO== null) {
            return Result.error(500, "登录信息为空");
        }
        User user = userService.loginUser(loginDTO);
        // 生成JWT令牌
        String token = jwtUtils.generateToken(user.getUsername(), user.getId());
        // 构建返回结果
        Map<String, Object> result = new HashMap<>();
        result.put("token", token);
        result.put("user", user);
        return Result.success("登录成功", result);
    }
}
```

# 3.mybits-plus分页

## 代码

### MybatisPlusConfig

```java
package com.zzt.blog.config;
/**
 * @author 227
 */
@Configuration
public class MybatisPlusConfig {

    /**
     * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题(该属性会在旧插件移除后一同移除)
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        PaginationInnerInterceptor paginationInnerInterceptor = new PaginationInnerInterceptor();
        // 设置数据库类型为MySQL
        paginationInnerInterceptor.setDbType(DbType.MYSQL);
        // 允许超出总页数后回到首页
        paginationInnerInterceptor.setOverflow(true);
        interceptor.addInnerInterceptor(paginationInnerInterceptor);
        return interceptor;
    }
}
```

这是 MyBatis-Plus 的配置类 [MybatisPlusConfig](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\config\MybatisPlusConfig.java#L13-L29)，主要用于配置 MyBatis-Plus 的分页插件和其他扩展功能。以下是详细的代码解析：

---

#### **核心作用**
1. **分页插件配置**  
   - 通过 `MybatisPlusInterceptor` 集成 MyBatis-Plus 的分页功能，支持 MySQL 数据库的分页查询。

2. **避免缓存问题**  
   - 使用新版分页插件，规避旧版插件的缓存问题（通过隐式设置 `useDeprecatedExecutor = false`）。

---

#### **代码逐行解析**
#### [mybatisPlusInterceptor](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\config\MybatisPlusConfig.java#L21-L29) 方法
1. **创建拦截器实例**  
   ```java
   MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
   ```

   - `MybatisPlusInterceptor` 是 MyBatis-Plus 的核心拦截器，用于加载各种内部插件。

2. **配置分页插件**  
   ```java
   PaginationInnerInterceptor paginationInnerInterceptor = new PaginationInnerInterceptor();
   paginationInnerInterceptor.setDbType(DbType.MYSQL); // 指定数据库类型
   paginationInnerInterceptor.setOverflow(true);      // 允许页码超出时回到首页
   ```

   - **DbType.MYSQL**：明确适配 MySQL 的分页语法（如 `LIMIT`）。
   - **overflow=true**：当请求页数超过总页数时，自动返回第一页数据（避免空结果）。

3. **将分页插件添加到拦截器**  
   
   ```java
   interceptor.addInnerInterceptor(paginationInnerInterceptor);
   ```
```
   
- 支持链式添加多个插件（如乐观锁、动态表名等）。
   
4. **返回配置完成的拦截器**  
   ```java
   return interceptor;
```

   - Spring 会将此拦截器注入到 MyBatis 的全局配置中。

---

#### **关键设计点**
1. **新版分页插件优势**  
   - 与 MyBatis 原生分页机制兼容性更好，避免旧版插件的缓存冲突问题。
   - 支持多数据库类型（通过 `setDbType` 指定）。

2. **overflow 参数的意义**  
   - **true**：用户请求页码超出范围时返回第一页（适合前端分页控件）。
   - **false**：直接返回空数据（严格模式）。

3. **扩展性**  
   - 可继续添加其他内置拦截器，例如：
     ```java
     interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); // 乐观锁
     ```


---

#### **实际效果示例**
- **SQL 生成**  
  当执行分页查询时：
  ```java
  Page<User> page = new Page<>(2, 10); // 第2页，每页10条
  userMapper.selectPage(page, null);
  ```

  MyBatis-Plus 会自动生成如下 SQL（MySQL 语法）：
  ```sql
  SELECT * FROM user LIMIT 10, 10;
  ```


- **超出页码处理**  
  若总页数为 5，但请求第 6 页：
  - `overflow=true`：返回第 1 页数据。
  - `overflow=false`：返回空列表。

---

#### **与其他组件的协作**
1. **与全局异常处理器配合**  
   
- 若分页参数非法（如页数为负数），会被 [GlobalExceptionHandler](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\exception\GlobalExceptionHandler.java#L67-L72) 捕获并返回标准错误响应。
  
2. **与 JWT 过滤器的关系**  
   
   - 分页查询通常需要认证（通过 [JwtAuthenticationFilter](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\config\JwtAuthenticationFilter.java#L30-L62) 验证令牌），但插件本身与认证无关。
   
     

### UserController

---

```java
package com.zzt.blog.controller;
/**
 * @author 227
 */ // 用户控制器
@RestController
@RequestMapping("/users")
@Tag(name = "用户管理")
public class UserController {
    @Autowired
    private UserService userService;
    @GetMapping("/UserPage")
    @Operation(summary = "分页获取用户列表")
    public Result<Map<String, Object>> userPage(@RequestParam(required = false, defaultValue = "1") Integer page,
                                                @RequestParam(required = false, defaultValue = "10") Integer size) {
        Map<String, Object> result = new HashMap<>();
        result.put("page", page);
        result.put("size", size);
        result.put("users", userService.getUserPage(page, size));
        return Result.success("获取成功", result);
}
}
```

### UserServiceImpl

```java
package com.zzt.blog.service.Impl;
/**
 * @author 227
 */
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {
    @Override
    public Page<User> getUserPage(Integer page, Integer size) {
        // 构建查询条件
        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
        //  只查询正常状态的用户, 按创建时间倒序排列
        wrapper.eq(User::getStatus, UserStatus.NORMAL)
                .orderByDesc(User::getCreateTime);

        // 执行分页查询
        return baseMapper.selectPage(new Page<>(page, size), wrapper);
    }
}
```

# 4.AOP切面编程思想实现日志的打印

## 依赖

```java
<!-- Spring AOP依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

## 代码

### LogAspect

```java
package com.zzt.blog.aspect;
/**
 * 操作日志切面
 * @author zzt
 */
@Aspect
@Component
@Slf4j
public class LogAspect {

    @Autowired
    private OperationLogService operationLogService;

    @Autowired
    private JwtUtils jwtUtils;

    /**
     * 定义切点 - 所有controller包下的所有方法
     */
    @Pointcut("execution(* com.zzt.blog.controller..*.*(..))")
    public void controllerPointcut() {}

    /**
     * 前置通知：在目标方法执行前执行
     */
    @Before("controllerPointcut()")
    public void doBefore(JoinPoint joinPoint) {
        // 获取请求信息
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        if (attributes == null) {
            return;
        }
        HttpServletRequest request = attributes.getRequest();

        // 记录请求内容
        log.info("请求URL: {}", request.getRequestURL().toString());
        log.info("请求方法: {}", request.getMethod());
        log.info("请求IP: {}", request.getRemoteAddr());
        log.info("调用方法: {}.{}", joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());
        log.info("返回当前用户id: {}", getCurrentUserId());
    }

    /**
     * 返回通知：在目标方法执行后执行
     */
    @AfterReturning(pointcut = "controllerPointcut()", returning = "result")
    public void doAfterReturning(JoinPoint joinPoint, Object result) {
        // 获取当前登录用户信息
        Long userId = getCurrentUserId();

        // 获取请求信息
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        if (attributes == null) {
            return;
        }
        HttpServletRequest request = attributes.getRequest();

        // 获取方法信息
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();

        // 创建操作日志对象
        OperationLog operationLog = new OperationLog();
        operationLog.setUserId(userId);
        operationLog.setOperation(method.getName());
        operationLog.setTargetType(joinPoint.getTarget().getClass().getSimpleName());
        operationLog.setDetail("调用了" + joinPoint.getSignature().getDeclaringTypeName() + "." + method.getName());
        operationLog.setIpAddress(request.getRemoteAddr());
        operationLog.setCreateTime(new Date());

        // 保存操作日志
        try {
            operationLogService.logOperation(operationLog);
        } catch (Exception e) {
            log.error("保存操作日志失败", e);
        }
    }

    /**
     * 获取当前登录用户ID
     */
    private Long getCurrentUserId() {
        try {
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            if (authentication != null && authentication.isAuthenticated() && !"anonymousUser".equals(authentication.getPrincipal())) {
                // 获取请求信息
                ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
                if (attributes != null) {
                    HttpServletRequest request = attributes.getRequest();
                    String authHeader = request.getHeader("Authorization");
                    if (authHeader != null && authHeader.startsWith("Bearer ")) {
                        String token = authHeader.substring(7);
                        // 从JWT令牌中获取userId
                        return jwtUtils.getUserIdFromToken(token);
                    }
                }
            }
        } catch (Exception e) {
            log.error("获取当前用户ID失败", e);
        }
        return null;
    }
    @Pointcut("@annotation(com.zzt.blog.annotation.LogOperation)")
    public void logOperationPointcut() {}

    @AfterReturning(pointcut = "logOperationPointcut()", returning = "result")
    public void doAfterReturningWithAnnotation(JoinPoint joinPoint, Object result) {
        // 获取注解信息
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        LogOperation logOperation = method.getAnnotation(LogOperation.class);

    }
}
```

这是一个基于Spring AOP的操作日志切面类 [LogAspect](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\aspect\LogAspect.java#L30-L122)，用于自动记录Controller层的操作日志。以下是核心功能的详细解析：

---

#### **核心功能**
1. **请求日志记录**  
   - 前置通知（`@Before`）记录请求基本信息（URL、方法、IP等）。
2. **操作日志持久化**  
   - 返回通知（`@AfterReturning`）保存操作日志到数据库。
3. **用户身份识别**  
   - 通过JWT令牌或Spring Security上下文获取当前用户ID。

---

#### **关键代码解析**

#### 1. **切点定义**
```java
@Pointcut("execution(* com.zzt.blog.controller..*.*(..))")
public void controllerPointcut() {} 
```

- 拦截`com.zzt.blog.controller`包下所有类的所有方法。

#### 2. **前置通知 [doBefore](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\aspect\LogAspect.java#L49-L63)**
```java
@Before("controllerPointcut()")
public void doBefore(JoinPoint joinPoint) {
    HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
    log.info("请求URL: {}", request.getRequestURL());
    log.info("请求IP: {}", request.getRemoteAddr());
    // ...其他日志
}
```

- **作用**：记录请求的基础信息，便于调试和监控。
- **技术点**：
  - 通过`RequestContextHolder`获取当前请求对象。
  - `JoinPoint`获取目标方法信息。

#### 3. **返回通知 [doAfterReturning](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\aspect\LogAspect.java#L66-L91)**
```java
@AfterReturning(pointcut = "controllerPointcut()", returning = "result")
public void doAfterReturning(JoinPoint joinPoint, Object result) {
    OperationLog log = new OperationLog();
    log.setUserId(getCurrentUserId()); // 获取当前用户
    log.setOperation(method.getName()); // 方法名
    log.setIpAddress(request.getRemoteAddr()); // IP
    operationLogService.logOperation(log); // 保存日志
}
```

- **作用**：持久化操作日志，包含用户、操作方法和IP等关键信息。
- **异常处理**：捕获日志保存异常，避免影响主流程。

#### 4. **用户ID获取 [getCurrentUserId](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\aspect\LogAspect.java#L94-L115)**
```java
private Long getCurrentUserId() {
    // 从Spring Security上下文获取
    Authentication auth = SecurityContextHolder.getContext().getAuthentication();
    if (auth != null && auth.isAuthenticated()) {
        // 从JWT令牌解析（备用方案）
        String token = request.getHeader("Authorization").substring(7);
        return jwtUtils.getUserIdFromToken(token);
    }
    return null;
}
```

- **双保险机制**：
  1. 优先从Spring Security上下文获取认证信息。
  2. 若失败，则直接从JWT令牌解析用户ID。

---

#### **扩展功能**
#### 自定义注解切点 [logOperationPointcut](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\aspect\LogAspect.java#L117-L122)
```java
@Pointcut("@annotation(com.zzt.blog.annotation.LogOperation)")
public void logOperationPointcut() {}

@AfterReturning("logOperationPointcut()")
public void doAfterReturningWithAnnotation(JoinPoint joinPoint) {
    // 可获取注解中的自定义操作描述
}
```

- **作用**：通过[@LogOperation](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\annotation\LogOperation.java#L8-L21)注解标记需要特殊记录的方法，实现更精细的日志控制。

---

#### **与其他组件的协作**
1. **与JWT过滤器的关系**  
   - 依赖 [JwtUtils](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\util\JwtUtils.java) 解析令牌中的用户ID。
2. **与异常处理器的协作**  
   - 若日志保存失败，异常会被 [GlobalExceptionHandler](file://D:\project\blog\blog-serve\src\main\java\com\zzt\blog\exception\GlobalExceptionHandler.java#L67-L72) 捕获。

---

#### **设计亮点**
1. **无侵入性**  
   - 通过AOP实现，无需修改业务代码。
2. **上下文完整性**  
   - 结合Spring Security和JWT多方式获取用户信息。
3. **可扩展性**  
   - 支持通过注解定制日志行为。

---

#### **典型日志示例**
```log
2025-05-27T14:45:54.034+08:00  INFO 6720 --- [blog-serve] [nio-8080-exec-6] com.zzt.blog.aspect.LogAspect            : 请求URL: http://localhost:8080/users/UserPage
2025-05-27T14:45:54.035+08:00  INFO 6720 --- [blog-serve] [nio-8080-exec-6] com.zzt.blog.aspect.LogAspect            : 请求方法: GET
2025-05-27T14:45:54.035+08:00  INFO 6720 --- [blog-serve] [nio-8080-exec-6] com.zzt.blog.aspect.LogAspect            : 请求IP: 0:0:0:0:0:0:0:1
2025-05-27T14:45:54.035+08:00  INFO 6720 --- [blog-serve] [nio-8080-exec-6] com.zzt.blog.aspect.LogAspect            : 调用方法: com.zzt.blog.controller.UserController.userPage
2025-05-27T14:45:54.036+08:00  INFO 6720 --- [blog-serve] [nio-8080-exec-6] com.zzt.blog.aspect.LogAspect            : 返回当前用户id: 17
```

# 5.统一返回结果

```java
package com.zzt.blog.util;
/**
 * @author 227
 */
@Data
public class Result<T>  {

    // 状态码
    private Integer code;
    // 提示信息
    private String message;
    // 响应数据
    private T data;
    // 时间戳
    private Date timestamp;

    /**
     * 成功响应（无数据）
     */
    public static <T> Result<T> success() {
        return success(null);
    }
    /**
     * 成功响应（带有xml提示信息）
     */
    public static <T> Result<T> success(String message) {
            Result<T> result = new Result<>();
            result.setCode(200);
            result.setMessage(message);
            result.setTimestamp(new Date());
            return result;
    }
    /**
     * 成功响应（带数据）
     */
    public static <T> Result<T> success(T data) {
        Result<T> result = new Result<>();
        result.setCode(200);
        result.setMessage("success");
        result.setData(data);
        result.setTimestamp(new Date());
        return result;
    }
    /**
     * 成功响应（带有xml提示信息）
     */
    public static <T> Result<T> success(String message, T data) {
        Result<T> result = new Result<>();
        result.setCode(200);
        result.setMessage(message);
        result.setData(data);
        result.setTimestamp(new Date());
        return result;
    }
    /**
     * 错误响应,没有错误信息
     */
    public static <T> Result<T> error( ) {
        Result<T> result = new Result<>();
        result.setCode(500);
        result.setMessage("error");
        result.setTimestamp(new Date());
        return result;
    }
    /**
     * 错误响应,只有错误信息
     */
    public static <T> Result<T> error( String message) {
        Result<T> result = new Result<>();
        result.setMessage(message);
        result.setCode(500);
        result.setTimestamp(new Date());
        return result;
    }
    /**
     * 错误响应
     */
    public static <T> Result<T> error(Integer code, String message) {
        Result<T> result = new Result<>();
        result.setCode(code);
        result.setMessage(message);
        result.setTimestamp(new Date());
        return result;
    }
    /**
     * 错误响应（带数据）
     */
    public static <T> Result<T> error(Integer code, String message, T data) {
        Result<T> result = new Result<>();
        result.setCode(code);
        result.setMessage(message);
        result.setData(data);
        result.setTimestamp(new Date());
        return result;
    }


}
```

# 6.连接redis

## 依赖

```java
<!--    hutool依赖，这里验证码的生成通过这个工具包-->
       <dependency>
          <groupId>cn.hutool</groupId>
          <artifactId>hutool-all</artifactId>
          <version>5.8.28</version> <!-- 使用最新版本 -->
       </dependency>
<!--       redis的依赖-->
       <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-data-redis</artifactId>
       </dependency>
       <dependency>
          <groupId>io.lettuce</groupId>
          <artifactId>lettuce-core</artifactId>
          <version>6.2.4.RELEASE</version>
       </dependency>
```

## 代码

### CapchaService

```java
package com.zzt.blog.service;
import org.springframework.data.redis.core.RedisTemplate;
/**
 * @author 227
 */
public interface CaptchaService {
    /**
     * 生成验证码并存入 Redis
     * @param key 验证码关联的键（如用户会话ID）
     * @return 验证码图片的 Base64 编码（可直接返回给前端）
     */
    String generateCaptcha(String key);
    /**
     * 验证用户输入的验证码
     * @param key 验证码关联的键
     * @param userInput 用户输入
     * @return 验证结果
     */
    boolean validateCaptcha(String key, String userInput);
}

package com.zzt.blog.service.Impl;
import cn.hutool.captcha.CaptchaUtil;
import cn.hutool.captcha.LineCaptcha;
import com.zzt.blog.service.CaptchaService;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import java.util.concurrent.TimeUnit;
/**
 * @author 227
 */
@Service
public class CaptchaServiceImpl implements CaptchaService {
    private final RedisTemplate<String, String> redisTemplate;
    
    public CaptchaServiceImpl(RedisTemplate<String, String> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }
    /**
     * 生成验证码并存入 Redis
     * @param key 验证码关联的键（如用户会话ID）
     * @return 验证码图片的 Base64 编码（可直接返回给前端）
     */
    @Override
    public String generateCaptcha(String key) {
        LineCaptcha captcha = CaptchaUtil.createLineCaptcha(200, 100);
        String code = captcha.getCode();
        
        // 存储到 Redis，设置10分钟过期
        redisTemplate.opsForValue().set(key, code, 10, TimeUnit.MINUTES);
        
        return captcha.getImageBase64Data();
    }

    /**
     * 验证用户输入的验证码
     * @param key 验证码关联的键
     * @param userInput 用户输入
     * @return 验证结果
     */
    @Override
    public boolean validateCaptcha(String key, String userInput) {
        String storedCode = redisTemplate.opsForValue().get(key);
        return userInput != null && userInput.equalsIgnoreCase(storedCode);
    }
}
```

### RedisConfig

```java
package com.zzt.blog.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer;

/**
 * @author 227
 */
@Configuration
public class RedisConfig {

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName("localhost");
        config.setPort(6379);
        config.setPassword("123456");
        config.setDatabase(0);
        //启用 Redis Session 存储
        //Session 过期时间（秒）

        return new LettuceConnectionFactory(config);
    }

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(new StringRedisSerializer());
        return template;
    }

}
```

这里，由于我使用的是springboot3，redis配置不再是通过yml文件来配置，而是通过在这个配置文件里面配置。

### CaptchaController

```java
package com.zzt.blog.controller;

import com.zzt.blog.service.CaptchaService;
import com.zzt.blog.util.Result;
import jakarta.servlet.http.HttpSession;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

/**
 * @author 227
 */
@RestController
@RequestMapping("/captcha")
public class CaptchaController {
    @Autowired
    private CaptchaService captchaService
    @GetMapping("/generate")
    public Result<String> generateCaptcha(HttpSession session) {
        String sessionId = session.getId();
        String captchaImage = captchaService.generateCaptcha(sessionId);
        return Result.success(captchaImage);
    }
}
```

通过controller层，前端获取到验证码

### UserController

```java
@Autowired
private CaptchaService captchaService;
@PostMapping("/login")
@Operation(summary = "登录用户")
public Result<Map<String, Object>> loginUser(@RequestBody LoginDTO loginDTO
        , HttpSession session ) {
    // 先校验验证码
    boolean isValid = captchaService.validateCaptcha(session.getId(), loginDTO.getCaptcha());
    if (!isValid) {
        return Result.error(401, "验证码错误");
    }
    User user = userService.loginUser(loginDTO);
    if(user== null) {
        return Result.error(500, "登录失败");
    }
    List<UserRole> roles = userRoleService.getRolesByUserId(user.getId());
    // 生成JWT令牌
    String token = jwtUtils.generateToken(user.getUsername(), user.getId(), roles);
    // 构建返回结果
    Map<String, Object> result = new HashMap<>();
    result.put("token", token);
    result.put("user", user);
    
    return Result.success("登录成功", result);
}
```

# 7.ai接口生成

## 依赖

```java
<!--		下面添加ai的依赖？-->
		<dependency>
			<groupId>org.springframework.ai</groupId>
			<artifactId>spring-ai-openai-spring-boot-starter</artifactId>
		</dependency>
```

## yam文件

```yaml
ai:
  openai:
    api-key: XXXXXXXXXXXXXXXXXXXX
    base-url: https://api.deepseek.com
    chat:
      options:
        model: deepseek-chat
        temperature: 0.7
```

## AiConfig.java

```java
@Bean
public OpenAiChatModel openAiChatModel() {
    OkHttpClient client = new OkHttpClient.Builder()
            .connectTimeout(Duration.ofSeconds(30))
            .readTimeout(Duration.ofSeconds(60))
            .writeTimeout(Duration.ofSeconds(60))
            .build();

    return new OpenAiChatModel(new OpenAiApi("https://api.deepseek.com","apikey"));
}
```

## AiChatController.java

```java
/**
 * @author 227
 */
@RestController
@RequestMapping("/ai")
public class AiChatController {

    @Autowired
    private ChatModel  chatModel;

    @GetMapping("/chat")
    public Result<String> chat(@RequestParam("message") String message) {
        ChatResponse chatResponse = chatModel.call(
                new Prompt(
                        "你是一个雌小鬼，知道互联网上一些低俗的笑话。" + message,
                        OpenAiChatOptions.builder()
                                .model("deepseek-chat")
                                .temperature(0.01)
                                .build()
                )
        );
        return Result.success("获取成功",chatResponse.getResult().getOutput().getContent());
    }
}
```

这个ai对话有很多中生成方式，还有一个流式，就是一个字一个字吐出来。

下面举几个其他的例子，估计还有更好的。

```java
@GetMapping(value = "/chat4",produces = "text/html;charset=UTF-8")
public String chat4(@RequestParam("name") String name
                   ,@RequestParam(value = "illeage") String illeage) {
    //设置用户输入信息
    String userText = """
            给我三个举报的方法
            """;
    UserMessage userMessage = new UserMessage(userText);
    //设置系统提示词
    String systemText = """
            你是一个律师，已经工作多年了，帮助很多人们
            你的名字是{name}
            你应该用法律武器来举报{illeage}
            """;
    //使用prompt template来设置系统提示词
    SystemPromptTemplate  systemPromptTemplate = new SystemPromptTemplate(systemText);

    //替换占位符
    Message message = systemPromptTemplate.createMessage(Map.of("name",name,"illeage",illeage));
    //设置系统提示词,使用Prompt封装对象
    Prompt prompt = new Prompt(List.of(userMessage,message));
    //调用chatModel.call方法
    ChatResponse chatResponse = chatModel.call(prompt);
    List<Generation> results = chatResponse.getResults();
    return
            results.stream().map(x->x.getOutput().getContent())
                    .collect(Collectors.joining(""));

}
```

```java
@GetMapping(value = "/chat2",produces = "text/html;charset=UTF-8")
public Flux<String> chat2(@RequestParam("message") String message) {
    return  chatModel.stream(message);
}
```

```java
@RestController
public class ChatController1 {
    @Autowired
    private ChatClient chatClient;
    @GetMapping("/chat1")
    public String chat(@RequestParam(value = "message",defaultValue = "你好，你是谁，你要干什么") String message){
        return chatClient.prompt().user(message).call().content();
    }
    @GetMapping(value = "/chatStream", produces = "text/html;charset=UTF-8")
    public Flux<String> chatStream(@RequestParam(value = "message",defaultValue = "你好，你是谁，你要干什么") String message){
        return chatClient.prompt().user(message).stream().content();
    }
}
```

```java
@RestController
public class ChatController {
    //注入ChatClient
    private final ChatClient chatClient;
    public ChatController(ChatClient.Builder chatClientBuilder){
        this.chatClient = chatClientBuilder.build();
    }
    //1.实现简单的对话
    @GetMapping("/chat")
    public String chat(@RequestParam(value="message",defaultValue = "hello,who are you?") String message){
        /**
         * 创建一个prompt，并设置用户的输入，然后调用call方法，获取机器人的回复。
         * 默认情况下，Spring AI会自动将prompt发送给OpenAI，并返回结果。
         * 可以通过自定义的ChatClient，实现更多的功能，如：
         * 1. 自定义prompt的格式
         * 2. 自定义OpenAI的API key
         * prompt的格式可以参考OpenAI的文档：https://beta.openai.com/docs/api-reference/completions/create,提示词
         * user(String userInput)方法可以设置用户的输入，调用call()方法获取机器人的回复。
         * call方法会返回一个CompletionResult对象，包含机器人的回复。
         * content()方法会返回机器人的回复。
         */
            return chatClient.prompt()
                    .user(message)
                    .call()
                    .content();
                }
}
```

```java
@Configuration
public class AiConfig {
    @Bean
    public ChatClient chatClient(ChatClient.Builder chatClientBuilder){
        return chatClientBuilder.defaultSystem("你的名字是227"+"你是一个实习生"+"你的首要任务是活下去").build();
    }
}
```

## <!-- AI助手悬浮按钮 -->

于此同时，我在前端还做了一个组件，是一个浮悬窗，我也把它放到下面

```vue
<template>
  <!-- AI助手悬浮按钮 -->
  <div 
    class="ai-assistant-button" 
    @mousedown="handleDragStart"
    :style="{
      left: `${buttonPosition.x}px`,
      top: `${buttonPosition.y}px`,
      right: 'auto',
      bottom: 'auto',
      cursor: isDragging ? 'grabbing' : 'grab'
    }"
  >
    <el-icon :size="30" color="#fff"><ChatDotRound /></el-icon>
  </div>

  <!-- AI对话弹窗 -->
  <el-dialog 
    v-model="aiDialogVisible" 
    title="AI助手" 
    width="500px"
    :close-on-click-modal="false"
    custom-class="ai-dialog"
  >
    <div class="chat-container">
      <div class="messages" ref="messagesContainer">
        <div 
          v-for="(message, index) in aiMessages" 
          :key="index"
          :class="['message', message.role]"
        >
          <div class="message-content">
            <div class="message-text">
              {{ message.content }}
              <span v-if="message.isLoading" class="loading-dots">{{ loadingDots }}</span>
            </div>
            <div class="message-time">{{ formatTime(message.timestamp) }}</div>
          </div>
        </div>
      </div>
      
      <div class="input-area">
        <el-input
          v-model="userInput"
          type="textarea"
          :rows="3"
          placeholder="请输入您的问题..."
          @keyup.enter.ctrl="sendToAi"
        />
        <div class="tips">按 Ctrl + Enter 发送</div>
        <div class="comment-actions">
          <el-button 
            type="primary" 
            @click="sendToAi"
            :loading="isAiLoading"
          >
            发送
          </el-button>
        </div>
      </div>
    </div>
  </el-dialog>
</template>

<script setup>
import { ref, onMounted, onUnmounted, nextTick, watch } from 'vue'
import { ChatDotRound } from '@element-plus/icons-vue'
import { getAiResponse } from '@/api/ai'

// AI对话相关状态
const aiDialogVisible = ref(false)
const userInput = ref('')
const aiMessages = ref([])
const isAiLoading = ref(false)
const messagesContainer = ref(null)
const loadingDots = ref('')

// 拖拽相关状态
const isDragging = ref(false)
const buttonPosition = ref({ x: window.innerWidth - 100, y: window.innerHeight - 100 })
const dragOffset = ref({ x: 0, y: 0 })
const dragStartTime = ref(0)

// 加载动画
const startLoadingAnimation = () => {
  let dots = 0
  loadingDots.value = ''
  const interval = setInterval(() => {
    dots = (dots + 1) % 4
    loadingDots.value = '.'.repeat(dots)
  }, 500)
  return interval
}

// 处理拖拽开始
const handleDragStart = (e) => {
  isDragging.value = true
  dragStartTime.value = Date.now()
  const rect = e.target.getBoundingClientRect()
  dragOffset.value = {
    x: e.clientX - rect.left,
    y: e.clientY - rect.top
  }
}

// 处理拖拽中
const handleDrag = (e) => {
  if (!isDragging.value) return
  
  const x = e.clientX - dragOffset.value.x
  const y = e.clientY - dragOffset.value.y
  
  // 限制在窗口范围内
  const maxX = window.innerWidth - 60 // 按钮宽度
  const maxY = window.innerHeight - 60 // 按钮高度
  
  buttonPosition.value = {
    x: Math.max(0, Math.min(x, maxX)),
    y: Math.max(0, Math.min(y, maxY))
  }
}

// 处理拖拽结束
const handleDragEnd = () => {
  const dragDuration = Date.now() - dragStartTime.value
  isDragging.value = false
  
  // 如果拖拽时间小于200ms，认为是点击
  if (dragDuration < 200) {
    toggleAiDialog()
  }
}

// 打开/关闭AI对话框
const toggleAiDialog = () => {
  aiDialogVisible.value = !aiDialogVisible.value
  // 如果打开对话框且没有历史消息，添加欢迎语
  if (aiDialogVisible.value && aiMessages.value.length === 0) {
    addAiMessage({
      role: 'ai',
      content: '你好！我是AI助手，有什么问题都可以问我。',
      timestamp: new Date()
    })
  }
}

// 添加消息到对话
const addAiMessage = (message) => {
  aiMessages.value.push(message)
  scrollToBottom()
}

// 滚动到底部
const scrollToBottom = () => {
  nextTick(() => {
    if (messagesContainer.value) {
      messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight
    }
  })
}

// 发送消息给AI
const sendToAi = async () => {
  if (!userInput.value.trim() || isAiLoading.value) return
  
  const userMessage = {
    role: 'user',
    content: userInput.value.trim(),
    timestamp: new Date()
  }
  
  addAiMessage(userMessage)
  console.log('用户消息:', userMessage.content)
  // 保存用户输入并清空输入框
  const message = userInput.value
  console.log('发送给AI的消息:', message)
  userInput.value = ''
  isAiLoading.value = true
  
  // 添加加载消息
  const loadingMessage = {
    role: 'ai',
    content: '思考中',
    timestamp: new Date(),
    isLoading: true
  }
  addAiMessage(loadingMessage)
  
  // 开始加载动画
  const loadingInterval = startLoadingAnimation()
  
  try {
    const response = await getAiResponse(message)
    
    // 移除加载消息
    aiMessages.value = aiMessages.value.filter(msg => !msg.isLoading)
    
    if (response.success) {
      addAiMessage({
        role: 'ai',
        content: response.data || response.message,
        timestamp: new Date()
      })
    } else {
      addAiMessage({
        role: 'ai',
        content: '抱歉，我暂时无法回答这个问题。请稍后再试。',
        timestamp: new Date()
      })
    }
  } catch (error) {
    // 移除加载消息
    aiMessages.value = aiMessages.value.filter(msg => !msg.isLoading)
    
    console.error('AI请求失败:', error)
    addAiMessage({
      role: 'ai',
      content: '服务连接异常，请检查网络后重试。',
      timestamp: new Date()
    })
  } finally {
    clearInterval(loadingInterval)
    isAiLoading.value = false
  }
}

// 格式化时间
const formatTime = (date) => {
  return new Date(date).toLocaleTimeString([], { 
    hour: '2-digit', 
    minute: '2-digit' 
  })
}

// 监听对话框打开状态，自动聚焦输入框
watch(aiDialogVisible, (val) => {
  if (val) {
    nextTick(() => {
      const input = document.querySelector('.input-area .el-input__inner')
      if (input) input.focus()
    })
  }
})

// 在组件挂载时添加全局事件监听
onMounted(() => {
  window.addEventListener('mousemove', handleDrag)
  window.addEventListener('mouseup', handleDragEnd)
})

// 在组件卸载时移除事件监听
onUnmounted(() => {
  window.removeEventListener('mousemove', handleDrag)
  window.removeEventListener('mouseup', handleDragEnd)
})
</script>

<style scoped>
.ai-assistant-button {
  position: fixed;
  width: 60px;
  height: 60px;
  background: linear-gradient(135deg, #6e8efb, #a777e3);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: grab;
  box-shadow: 0 4px 12px rgba(110, 142, 251, 0.3);
  z-index: 1000;
  transition: box-shadow 0.3s ease;
  user-select: none;
}

.ai-assistant-button:hover {
  box-shadow: 0 6px 16px rgba(110, 142, 251, 0.4);
}

.ai-assistant-button:active {
  cursor: grabbing;
}

/* 聊天容器 */
.chat-container {
  display: flex;
  flex-direction: column;
  height: 60vh;
  border-radius: 8px;
  overflow: hidden;
}

.messages {
  flex: 1;
  overflow-y: auto;
  padding: 15px;
  background-color: #f9fafc;
  border-radius: 8px 8px 0 0;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.message {
  display: flex;
  gap: 12px;
}

.message.ai {
  align-items: flex-start;
}

.message.user {
  flex-direction: row-reverse;
  align-items: flex-start;
}

.message-content {
  max-width: 80%;
  padding: 12px 16px;
  border-radius: 18px;
  position: relative;
}

.message.ai .message-content {
  background-color: #fff;
  border: 1px solid #e4e7ed;
  border-radius: 18px 18px 18px 4px;
}

.message.user .message-content {
  background: linear-gradient(135deg, #6e8efb, #a777e3);
  color: white;
  border-radius: 18px 18px 4px 18px;
}

.message-text {
  line-height: 1.6;
  white-space: pre-wrap;
  word-break: break-word;
}

.message-time {
  font-size: 12px;
  color: #999;
  margin-top: 4px;
  text-align: right;
}

.input-area {
  padding: 15px 0 0;
}

.tips {
  font-size: 12px;
  color: #999;
  text-align: right;
  margin-top: 5px;
}

.comment-actions {
  margin-top: 15px;
  display: flex;
  justify-content: flex-end;
}

.loading-dots {
  display: inline-block;
  min-width: 20px;
  animation: blink 1s infinite;
}

@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
</style>

<style>
/* 覆盖Element UI样式 */
.ai-dialog .el-dialog__header {
  background: linear-gradient(135deg, #6e8efb, #a777e3);
  margin: 0;
  padding: 15px 20px;
}

.ai-dialog .el-dialog__title {
  color: white;
}

.ai-dialog .el-dialog__headerbtn .el-dialog__close {
  color: white;
}
</style> 
```

# 8.返回树状结构

```java
// 1. 获取所有未删除的目录数据
LambdaQueryWrapper<CatalogResourceCatalog> lqw = Wrappers.lambdaQuery();
lqw.eq(CatalogResourceCatalog::getDelFlag, "0");
List<CatalogResourceCatalog> allCatalogs = baseMapper.selectList(lqw);

// 2. 转换为VO对象并创建一个映射，方便通过ID查找
List<CatalogResourceCatalogVo> allCatalogVos = MapstructUtils.convert(allCatalogs, CatalogResourceCatalogVo.class);
Map<Long, CatalogResourceCatalogVo> catalogMap = allCatalogVos.stream()
    .collect(Collectors.toMap(CatalogResourceCatalogVo::getId, Function.identity()));

// 3. 准备一个列表来存储顶层节点
List<CatalogResourceCatalogVo> topLevelNodes = new ArrayList<>();

// 4. 构建树形结构：将子节点添加到其父节点的children列表中
for (CatalogResourceCatalogVo vo : allCatalogVos) {
    Long parentId = vo.getParentId();
    // 如果parentId为null或0，则认为是顶层节点
    if (parentId == null || parentId == 0L) {
        topLevelNodes.add(vo);
    } else {
        CatalogResourceCatalogVo parent = catalogMap.get(parentId);
        if (parent != null) {
            if (parent.getChildren() == null) {
                parent.setChildren(new ArrayList<>());
            }
            parent.getChildren().add(vo);
        }
        // 如果找不到父节点，可以考虑将其作为顶层节点，或者忽略
        // 这里假设数据完整性，所有有parentId的节点都能找到其父节点
    }
}

// 5. 创建一个虚拟的根节点，并将所有顶层节点作为其子节点
CatalogResourceCatalogVo dummyRoot = new CatalogResourceCatalogVo();
// 虚拟根节点的ID，可以根据实际情况调整
dummyRoot.setId(0L);
// 虚拟根节点的名称
dummyRoot.setName("所有目录");
// 将所有顶层节点作为其子节点
dummyRoot.setChildren(topLevelNodes);
```



### 1.首先获取到没有被删除的数据

LambdaQueryWrapper<CatalogResourceCatalog> lqw = Wrappers.lambdaQuery();
lqw.eq(CatalogResourceCatalog::getDelFlag, "0");
List<CatalogResourceCatalog> allCatalogs = baseMapper.selectList(lqw);

```

- **目的**：从数据库中查询出所有 `del_flag` 为 `"0"`（即未删除）的目录数据。
- **说明**：
  - 使用 [LambdaQueryWrapper](file://com\baomidou\mybatisplus\core\conditions\query\LambdaQueryWrapper.java#L10-L26) 构建查询条件，确保只获取有效数据。
  - [selectList](file://D:\work\data-exchange\data-exchange-platform-server\data-exchange-modules\data-exchange-system\src\main\java\org\dromara\system\service\ISysTenantPackageService.java#L30-L30) 方法返回的是一个包含所有目录实体对象 ([CatalogResourceCatalog](file://D:\work\data-exchange\data-exchange-platform-server\data-exchange-modules\data-exchange-plateform\src\main\java\org\dromara\plateform\catalog\domain\CatalogResourceCatalog.java#L15-L56)) 的列表。




```

### 2. **转换为 VO 对象并创建映射**
```java
List<CatalogResourceCatalogVo> allCatalogVos = MapstructUtils.convert(allCatalogs, CatalogResourceCatalogVo.class);
Map<Long, CatalogResourceCatalogVo> catalogMap = allCatalogVos.stream()
    .collect(Collectors.toMap(CatalogResourceCatalogVo::getId, Function.identity()));
```

- **目的**：
  - 将原始数据 (`CatalogResourceCatalog`) 转换为视图对象 (`CatalogResourceCatalogVo`)，以便返回给前端。
  - 创建一个 `Map`，通过 `id` 快速查找对应的目录对象。
- **说明**：
  - `MapstructUtils.convert` 是工具类方法，用于将实体对象批量转换为 VO 对象。
  - 使用 Java Stream 的 `Collectors.toMap` 方法，构建一个以 `id` 为键、VO 对象为值的映射表。

---

### 3. **准备存储顶层节点的列表**
```java
List<CatalogResourceCatalogVo> topLevelNodes = new ArrayList<>();
```

- **目的**：存储所有没有父级的顶级目录节点。
- **说明**：
  - 这些顶级节点的 `parentId` 通常为 `null` 或 `0L`，表示它们是根节点。

---

### 4. **构建树形结构**
```java
for (CatalogResourceCatalogVo vo : allCatalogVos) {
    Long parentId = vo.getParentId();
    if (parentId == null || parentId == 0L) {
        topLevelNodes.add(vo); // 添加到顶层节点
    } else {
        CatalogResourceCatalogVo parent = catalogMap.get(parentId);
        if (parent != null) {
            if (parent.getChildren() == null) {
                parent.setChildren(new ArrayList<>()); // 初始化子节点列表
            }
            parent.getChildren().add(vo); // 将当前节点添加到父节点的子节点列表中
        }
    }
}
```

- **目的**：遍历所有目录对象，根据 `parentId` 构建父子关系。
- **说明**：
  - 如果 `parentId` 为 `null` 或 `0L`，则认为是顶层节点，直接加入 `topLevelNodes`。
  - 否则，从 `catalogMap` 中找到其父节点，并将当前节点添加到父节点的 `children` 列表中。
  - 如果父节点不存在，则忽略该节点（这里假设数据完整性良好）。

---

### 5. **创建虚拟根节点**
```java
CatalogResourceCatalogVo dummyRoot = new CatalogResourceCatalogVo();
dummyRoot.setId(0L);
dummyRoot.setName("所有目录");
dummyRoot.setChildren(topLevelNodes);
```

- **目的**：创建一个虚拟的根节点，将所有顶层节点作为它的子节点。
- **说明**：
  - 虚拟根节点本身并不是实际存在的目录，仅用于统一展示层级结构。
  - 设置了虚拟根节点的 [id](file://D:\work\data-exchange\data-exchange-platform-server\data-exchange-modules\data-exchange-plateform\src\main\java\org\dromara\plateform\catalog\domain\CatalogResourceCatalog.java#L26-L27) 和 [name](file://D:\work\data-exchange\data-exchange-platform-server\data-exchange-modules\data-exchange-plateform\src\main\java\org\dromara\plateform\catalog\domain\CatalogResourceCatalog.java#L42-L42)，并将其 [children](file://D:\work\data-exchange\data-exchange-platform-server\data-exchange-modules\data-exchange-system\src\main\java\org\dromara\system\domain\SysDept.java#L88-L89) 属性指向 `topLevelNodes`。

---

### 